from collections import defaultdict
from datetime import datetime

from shapely import geometry
from shapely.ops import cascaded_union
import utils
import pyproj
import uom
from config import db

from sql import select, upsert, delete

from grid import Grids

import math

import logging


class NullHandler(logging.Handler):
    def emit(self, record):
        pass

log = logging.getLogger('IST_TEST')
log.addHandler(NullHandler())


class Angle(object):
    def __init__(self):
        """
        ist_angles (starts from North) is an ordered list of correct angle (start from East)
        """
        self._right_ordered_radian = None
        self._ist_ordered_radian = None

    def _generate(self):
        start = 90
        self._right_ordered_radian = []
        self._ist_ordered_radian = []
        for degree in range(0, 360):
            self._right_ordered_radian.append(float(degree) * math.pi / 180.0)
            self._ist_ordered_radian.append(float(start) * math.pi / 180.0)
            start -= 1


    @property
    def radians(self):
        if self._right_ordered_radian is not None:
            return self._right_ordered_radian
        self._generate()
        return self._right_ordered_radian

    @property
    def ist_angles(self):
        if self._ist_ordered_radian is not None:
            return self._ist_ordered_radian
        self._generate()
        return self._ist_ordered_radian


radians = Angle()


def Point(longitude, latitude):
    return geometry.Point(longitude, latitude)


class Field(object):
    _grids = None
    _field_id = None
    _field_polygon = None
    _x_degree = None
    _y_degree = None

    def __init__(self, centroid, radius, account_device_id=88, db=db):
        assert isinstance(centroid, geometry.Point), "centroid must be a Point instance"
        assert isinstance(radius, uom.Uom), "radius must be a Uom instance"
        self.radius = radius
        self.centroid = centroid
        self.account_device_id = account_device_id
        self.db = db
        self._map_grid_by_ist_degree_angle = defaultdict(list)
        self._map_field_management_zone_by_id = {}


    @property
    def my_proj(self):
        return pyproj.Proj("+proj=eck4 +lat_0={lat} +lon_0={long}, init='epsg:4326".format(
            long=self.centroid.x,
            lat=self.centroid.y))

    @property
    def x_radius_degree(self):
        if self._x_degree is not None:
            return self._x_degree

        UTMx, UTMy = self.my_proj(self.centroid.x, self.centroid.y, inverse=False)
        long, _ = self.my_proj(UTMx + self.radius.convert(uom.Meter), UTMy, inverse=True)

        self._x_degree = abs(self.centroid.x - long)
        return self._x_degree

    @property
    def y_radius_degree(self):
        if self._y_degree is not None:
            return self._y_degree

        UTMx, UTMy = self.my_proj(self.centroid.x, self.centroid.y, inverse=False)
        _, lat = self.my_proj(UTMx, UTMy + self.radius.convert(uom.Meter), inverse=True)

        self._y_degree = abs(self.centroid.y - lat)
        return self._y_degree

    def get_angle_polygon(self, angle_degree):
        """
        this function will return the polygon (4326) by IST-angle_degree provided in integer
        :return: polygon
        """
        start_degree = radians.ist_angles[angle_degree - 1]
        end_degree = radians.ist_angles[angle_degree]
        list_points = []

        list_points.append(geometry.Point(self.centroid.x + self.x_radius_degree * math.cos(start_degree),
                                              self.centroid.y + self.y_radius_degree * math.sin(start_degree)))

        list_points.append(geometry.Point(self.centroid.x + self.x_radius_degree * math.cos(end_degree),
                                          self.centroid.y + self.y_radius_degree * math.sin(end_degree)))

        list_points.append(self.centroid)

        return cascaded_union(list_points).convex_hull

    def get_grids_by_angle(self, angle_degree):
        sql = select.get_grids_by_angle
        angle_polygon = self.get_angle_polygon(angle_degree)
        input = dict(polygon_wkt=angle_polygon.wkt)

        # print sql % (input)
        ret = self.db.fetch_all_rows(sql, input)

        return ret.query_data

    @property
    def field_polygon(self):
        """
        Field polygon is generated by simple function with 99 points
        :return: shapely.geometry.polygon
        """
        if self._field_polygon is not None:
            return self._field_polygon

        list_points = []
        for degree in radians.radians:
            list_points.append(geometry.Point(self.centroid.x + self.x_radius_degree * math.cos(degree),
                                              self.centroid.y + self.y_radius_degree * math.sin(degree)))

        self._field_polygon = cascaded_union(list_points).convex_hull

        return self._field_polygon

    @property
    def field_id(self):
        """
        get field_id from database based on 80% overlapped
        :return: field_id
        """
        if self._field_id is not None:
            return self._field_id

        input = dict(polygon_wkt=self.field_polygon.wkt)

        field_info = self.db.fetch_one_row(select.get_field_based_on_80per_overlapped, input)
        if field_info.query_data is None:
            return self.import_field()

        self._field_id = field_info.query_data.id
        return self._field_id

    def import_field(self):
        """
        import field to database and get field_id
        :return: field_id
        """

        input = dict(account_device_id=self.account_device_id,
                     polygon_wkt=self.field_polygon.wkt)

        field_info = db.fetch_one_row(upsert.insert_field, input)
        if field_info.query_data is None:
            raise ValueError("import failed")

        self._field_id = field_info.query_data.id

        return self._field_id

    @property
    def grids(self):
        if self._grids is not None:
            return self._grids
        min_long, min_lat, max_long, max_lat = self.field_polygon.bounds
        grids = Grids(min_long=min_long, min_lat=min_lat, max_long=max_long, max_lat=max_lat)
        self._grids = []
        for grid in grids.grids:
            if self.field_polygon.intersects(grid.polygon):
                self.grids.append(grid)

        return self._grids


    def import_grids(self):

        log.info("Import grids- total: {}".format(len(self.grids)))
        # clean before import
        self.db.modify_rows(delete.clean_grids, dict(field_id=self.field_id))

        insert_values = []

        start_time = datetime.now()

        for grid in self.grids:
            insert_value = '({},{})'.format(self.field_id, grid.polygon_sql)
            insert_values.append(insert_value)

        insert_values = ','.join(insert_values)
        insert_values = upsert.insert_grids.format(values=insert_values)

        self.db.modify_rows(insert_values)

        log.info("Import grids- Run time: {}".format(datetime.now() - start_time))









